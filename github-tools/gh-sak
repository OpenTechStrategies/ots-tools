#!/usr/bin/env python3
# -*- coding: utf-8 -*-
#
# gh-sak: A GitHub "Swiss Army knife" for doing batch manipulation of
#         things (issues, labels, etc) in a GitHub repository.
# 
# github.com/OpenTechStrategies/ots-tools/blob/master/github-tools/gh-sak
#
# Copyright (C) 2018 Open Tech Strategies, LLC
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published
# by the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program. If not, see <http://www.gnu.org/licenses/>.

__doc__ = """\
Manipulate issues associated with a GitHub repository.  Usage:

  $ ./gh-sak --root OWNER[/REPOS] [ --infile INPUT_FILE ] COMMAND

OWNER/REPOS is something like "opentechstrategies/ots-tools".

Some COMMANDs, e.g., listing all issues, require no further specification.
Others COMMANDs, such as determining different labels across a bunch
of issues, operate batch-style on an input set passed via INPUT_FILE.
INPUT_FILE is a JSON-format file whose structure depends on COMMAND.

GitHub authentication and authorization
---------------------------------------

Each time you run this script, you will be prompted for a GitHub
authorization token.  If you don't want to be prompted, put the token
as the first line of a file (you might want to restrict that file's
permissions so that only you can read it) and pass the file with the
'--auth-token-file' option, like so:

  $ ./gh-sak --auth-token-file FILE_CONTAINING_TOKEN ...

(We don't offer a way to pass the token directly via the command line
because then it could be leaked via 'ps' listings, shell history, etc.)

Available COMMANDs
------------------

* "list-repositories"  (no input file)

   List all the repositories under OWNER (i.e., use with '--root OWNER').

   This is the only command for which the /REPOSITORY component of the
   parameter to the --root option is not required (indeed, must be
   left off).

* "issues-summary-org"  OR  "pull-requests-summary-org"  (no input file)

  This lists all issues (or pull requests), both open and closed, in
  an Emacs Org Mode format, like so:

    * [[https://github.com/blah/blah/issues/3][3]]   (open): issue title
  
      body (i.e., first comment) here
  
    ** LABELS
       - some label name
       - another label name

    * [[https://github.com/blah/blah/issues/2][1]]   (open): other title
  
      other body (i.e., first comment) here
  
    * [[https://github.com/blah/blah/issues/1][1]] (closed): another title
  
      another body (i.e., first comment) here

    ** LABELS
       - some label name
       - yet a third distinct label name

* "list-labels"  (no input file)

  Print a list of all labels in the repository, one per line.

* "edit-issues"  (input file required)

  Manipulate issues in various ways.  Right now, the only manipulation
  supported is adding/removing existing labels to/from issues.  (See
  also the "edit-labels" command.)

  The top level structure of the JSON is a list.  Each element of that
  list is a dictionary.  The only required entry in each dictionary is
  "issue", whose value is an issue number (an integer), and each
  remaining entry is an action to take regarding that issue.  The two
  actions implemented so far are "add-labels" and "remove-labels",
  and the value in both cases is a list of label names (strings).
  For example:

    [
        {
            "issue":         1729,
            "add-labels":    ["REQ-1", "HARD"],
            "remove-labels": ["REQ-5", "EASY"]
	},
        ...
    ]

  Labels will be created as necessary, always with a gray background,
  but if a label already exists its current color will not be changed.

  Removing a label that doesn't exist is merely a no-op, not an error.

  List elements are processed in order from top to bottom; it's fine,
  though somewhat silly, for the same issue to appear multiple times.

* "edit-labels"  (input file required)

  Create, delete, rename, and change colors of labels.

  The JSON is a list of sublists:

    [ [ OLD_LABEL_NAME, NEW_LABEL_NAME, COLOR ] ...]

  Each sublist can be used to create a new label, delete an existing
  label, rename a label, change the color of a label, or rename and
  change color simultaneously.  This logic chart explains how:

    OLD_LABEL_NAME null:
      NEW_LABEL_NAME null:
        COLOR null:     ==>  ERROR
        COLOR "color":  ==>  ERROR
      NEW_LABEL_NAME "new_name":
        COLOR null:     ==>  create new label with default gray ("e2e2e2")
        COLOR "color":  ==>  create new label with color "color"
    OLD_LABEL_NAME "old_name"
      NEW_LABEL_NAME null:
        COLOR null:     ==>  delete old label
        COLOR "color":  ==>  give old label new color "color"
      NEW_LABEL_NAME "new_name":
        COLOR null:     ==>  rename label but preserve old color
        COLOR "color":  ==>  rename label and give it new color "color"

  The top-level list is processed in order, and each element takes
  effect as soon as it is processed.

Notes
-----

This code is not librarized yet.  To be a library, it would need at
least these changes:

   - All the errors followed by sys.exit(1) would need to become
     exceptions raised.

   - The inline print statements would need to be omitted or become
     some kind of progress callback.
"""

import sys
import time
import getopt
import getpass
import json
import requests

def get_input(infile):
    """Return the data structure represented by the JSON in INFILE.
    If INFILE is None, exit with usage recommendation and error."""
    if infile is None:
        sys.stderr.write("ERROR: "
                         "'--input-file INPUT_FILE' required\n"
                         "       (run with --help to see usage)\n")
        sys.exit(1)
    return json.load(infile)


def do_query(query, headers):
    """Send QUERY to GitHub (v4 GraphQL API) and return the response."""
    request = requests.post('https://api.github.com/graphql', 
                            json={'query': query}, 
                            headers=headers)
    if request.status_code == 200:
        return request.json()
    else:
        raise Exception("ERROR: error {} returned for query \"{}\".".format(
            request.status_code, query))


def main():
    command = None
    owner_name = None
    repos_name = None
    infile = None
    auth_token = None

    try:
        (opts, args) = getopt.getopt(
            sys.argv[1:], "h?", 
            ["help", "usage", "auth-token-file=", "root=", "infile=",])
    except getopt.GetoptError as err:
        sys.stderr.write(str(err))
        sys.stderr.write("\n")
        sys.exit(1)

    for opt, optarg in opts:
        if opt in ("-h", "-?", "--help", "--usage",):
            print(__doc__)
            sys.exit(0)
        elif opt in ("--auth-token-file",):
            with open(optarg, "r") as f:
                auth_token = f.readline().rstrip()
        elif opt in ("--root",):
            # '--repository' for backwards compatibility only
            try:
                owner_name, repos_name = optarg.split("/")
            except ValueError:
                owner_name = optarg
            if owner_name == "":
                owner_name = None
            if repos_name == "":
                repos_name == None
        elif opt in ("--infile",):
            if optarg == "-":
                infile = sys.stdin
            else:
                infile = open(optarg, "r")
        
    if len(args) == 1:
        command = args[0]
    elif len(args) < 1:
        sys.stderr.write("ERROR: "
                         "command required (run with --help to see usage)\n")
        sys.exit(1)
    else:
        sys.stderr.write("ERROR: "
                         "too many commands (run with --help to see usage)\n")
        sys.exit(1)

    if ((owner_name is None)
        or ((command != "list-repositories") and (repos_name is None))):
        sys.stderr.write("ERROR: '--root' option must supply "
                         "owner and (usually) repository, like this:\n")
        sys.stderr.write("\n")
        sys.stderr.write("  owner_name/repository_name\n")
        sys.stderr.write("\n")
        sys.stderr.write("For example:\n")
        sys.stderr.write("\n")
        sys.stderr.write("  solutionguidance/psm\n")
        sys.stderr.write("\n")
        sys.stderr.write("(The repository_name may be omitted for "
                         "the \"list-repositories\" command.)\n")
        sys.stderr.write("\n")
        sys.exit(1)

    if auth_token is None:
        auth_token = getpass.getpass("GitHub authorization token ('?' for help): ")
    if auth_token == "?" or auth_token == "":
        print("https://help.github.com/articles/"
              "creating-a-personal-access-token-for-the-command-line")
        print("has instructions for generating a GitHub API personal"
              "access token.")
        print("")
        auth_token = getpass.getpass("GitHub authorization token: ")

    headers = {"Authorization": "Bearer {}".format(auth_token)}

    # https://graphql.org/learn/pagination/ is a great resource on
    # pagination models.  GitHub uses the cursor model.
    # 
    # Some other useful pages:
    # 
    #   - https://developer.github.com/v4/
    #   - https://developer.github.com/v4/explorer/
    #   - https://developer.github.com/v4/guides/forming-calls/#example-query
    #   - https://developer.github.com/v4/object/repository/
    #   - https://developer.github.com/v4/guides/intro-to-graphql/
    #   - GitHub GraphQL API Starred Repositories Examples With Pagination
    #     https://gist.github.com/obahareth/d974afa16ac84182abc293b306e25928
    #   - https://medium.com/@mattmazzola/graphql-pagination-implementation-8604f77fb254
    #   - https://developer.github.com/v4/guides/migrating-from-rest/
    query_template = """
    {{
      repository(owner: "{}", name: "{}") {{
        issues(first: {}{}) {{
          totalCount
          edges {{
            node {{
              number
              title
              state
              labels(first: {}) {{
                totalCount
                edges {{
                  node {{ 
                    name
                    description
                  }}
                  cursor
                }}
              }}
            }}
            cursor
          }}
        }}
      }}
    }}
    """

    requested_page_size = 100
    after_str_issues = ""  # could be ", after: \"some_cursor\""
    total_count = None
    total_remaining = sys.maxsize

    while total_remaining > 0:
        this_query = query_template.format(
            owner_name, repos_name, 
            requested_page_size, after_str_issues, requested_page_size)
        # TODO: Dancing the nested-after dance for labels will be a pain.
        #       There has to be a good abstraction for this.  Hmmmmm.
        result = do_query(this_query, headers)

        these_issues = result["data"]["repository"]["issues"]["edges"]
        last_issue_cursor = these_issues[-1]["cursor"]
        total_fetched = len(these_issues)

        if total_count is None:
            # This total will never change after being set.
            total_count = result["data"]["repository"]["issues"]["totalCount"]
            total_remaining = total_count - total_fetched
        else:
            total_remaining = total_remaining - total_fetched

        print("%s" % json.dumps(result, indent=4, sort_keys=True))

        if total_remaining > 0:
            after_str_issues = ", after: \"{}\"".format(last_issue_cursor)

        print("%d fetched; %d (of %d) remaining" 
              % (total_fetched, total_remaining, total_count))
        
        

if __name__ == '__main__':
    main()
