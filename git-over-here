#!/bin/bash

# git-over-here: Switch multiple repositories from an old Git remote
#                origin to a new one and, optionally, to a new branch.
#
# Search for "help" below to learn how to use this.

# Copyright (c) 2022 Open Tech Strategies, LLC
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
# 
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# General Public License for more details.
# 
# If you did not receive a copy of the GNU General Public License
# along with this program, see <http://www.gnu.org/licenses/>.

help () {
  read -d '' HELP_OUTPUT << EOF
Usage:

   $ git-over-here -r OLD_REMOTE NEW_REMOTE [-b OLD_BRANCH NEW_BRANCH] DIR

From DIR downward switch every Git repository whose 'origin' remote is
OLD_REMOTE to NEW_REMOTE.  If OLD_REMOTE and NEW_REMOTE are the same,
then don't change any remotes, but use the specified remote to
determine which repositories the -b option (see below) affects.

With -b option added, then for all repositories that had an origin of
OLD_REMOTE, rename branch OLD_BRANCH to NEW_BRANCH and set origin's
upstream branch to NEW_REMOTE.  (A typical use is to change "master"
to "main" across a bunch of repositories.)

This script does not push to any remotes.  Our assumption is that
someone has already made the changes upstream and people just need to
update their local clones.

Matching of remote names is case-insensitive, but matching of
branch names is case-sensitive.

Both -r and DIR are required; -b is optional.  DIR must be the last
thing on the command line.

EOF
  echo "${HELP_OUTPUT}" >&2
}

ROOT_DIR=""
OLD_REMOTE=""
NEW_REMOTE=""
OLD_BRANCH=""
NEW_BRANCH=""

_MESSUP="no"  # set to "yes" if problem found in arg parsing

if [ "${1}" = "-r" ]
then
  OLD_REMOTE="${2}"
  NEW_REMOTE="${3}"
  if [ "${4}" = "-b" ]
  then
    OLD_BRANCH="${5}"
    NEW_BRANCH="${6}"
    ROOT_DIR="${7}"
  else
    ROOT_DIR="${4}"
  fi
else
  echo "ERROR: Missing -r option" >&2
  _MESSUP="yes"
fi

# If mis-invoked, carefully detect how and report it.
if [ "${OLD_REMOTE}" = "" ]; then
  echo "ERROR: Missing OLD_REMOTE" >&2
  _MESSUP="yes"
fi
if [ "${NEW_REMOTE}" = "" -o "${NEW_REMOTE}" = "-b" ]; then
  echo "ERROR: Missing NEW_REMOTE" >&2
  _MESSUP="yes"
fi
if [ "${ROOT_DIR}" = "" ]; then
  echo "ERROR: Missing DIR" >&2
  _MESSUP="yes"
fi
if [ "${OLD_BRANCH}" != "" -a "${NEW_BRANCH}" = "" ]; then
  _MESSUP="yes"
  echo "ERROR: Missing NEW_BRANCH" >&2
fi
if [ "${_MESSUP}" = "yes" ]; then
  echo "" >&2
  help
fi

for DOT_GIT_DIR in `find "${ROOT_DIR}" -type d -name "\.git" -print`; do
  SAVED_CWD="`pwd`"
  cd "${DOT_GIT_DIR}/../" || continue
  HERE_ORIGIN="`git remote get-url origin`"
  if [ "${HERE_ORIGIN,,}" = "${OLD_REMOTE,,}" ]; then
    echo "* In '`pwd`':"
    # If the two remotes are equivalent (case-insensitively),
    # then don't touch the remote at all.
    if [ "${OLD_REMOTE,,}" != "${NEW_REMOTE,,}" ]; then
      # We don't pass "${OLD_REMOTE}" at the end below because Git's
      # confirmation check is (perhaps surprisingly) case-sensitive.
      git remote set-url origin "${NEW_REMOTE}"
      echo "  Switched origin remote to '${NEW_REMOTE}'."
    fi
    if [ "${OLD_BRANCH}" != "" ]; then
      if [ -n "`git status --porcelain=v1 2>/dev/null`" ]; then
        echo "  SKIPPING branch change in '`pwd`':" >&2
        echo "  There are uncommitted changes here." >&2
        echo "  Please 'git stash' the changes and try again." >&2
        echo ""
        cd "${SAVED_CWD}"
        continue
      fi
      # If the new branch already exists, this will produce an error
      # (because we used -m instead of -M), which is what we want.
      if git branch --track=inherit -m "${OLD_BRANCH}" "${NEW_BRANCH}"; then
        # Although it's not documented in the 'git branch' man page,
        # if you were on ${OLD_BRANCH} when you ran the above command
        # then you'll be automatically switched to ${NEW_BRANCH}.
        if [ "`git branch --show-current`" != "${NEW_BRANCH}" ]; then
          echo "  SKIPPING branch change in '`pwd`':" >&2
          echo "  This directory is on branch '`git branch --show-current`'." >&2
          echo "  Please put it on '${NEW_BRANCH}' branch and try again." >&2
          echo ""
          cd "${SAVED_CWD}"
          continue
        fi
        git symbolic-ref refs/remotes/origin/HEAD refs/remotes/origin/"${NEW_BRANCH}"
        git pull --quiet --set-upstream origin "${NEW_BRANCH}"
        echo "  Renamed branch '${OLD_BRANCH}' to '${NEW_BRANCH}'."
      else
        echo "  CHECK '`pwd`':" >&2
        echo "  Given that branch ${NEW_BRANCH} already exists," >&2
        echo "  you might already be set up correctly here." >&2
        echo "  (That's what the 'fatal' error above is about;" >&2
        echo "  everything might actually be fine.)" >&2
      fi
    fi
  echo ""
  fi
  cd "${SAVED_CWD}"
done
