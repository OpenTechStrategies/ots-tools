#!/bin/bash

# *** WARNING WARNING WARNING WARNING WARNING WARNING WARNING ***
# ***                                                         ***
# ***       DRAFT   ***   WORK-IN-PROGRESS   ***   DRAFT      ***
# ***                                                         ***
# ***   This is still being written as of 2022-10-16.  Yes,   ***
# ***   I could just keep it on a branch, but I'd rather      ***
# ***   endanger everyone around me.  Please don't use it     ***
# ***   yet, though -- it's not ready.  When this notice      ***
# ***   goes away, that means I'm at least willing to use     ***
# ***   this on my own data.  Your Mileage May Vary (TM).     ***
# ***                                                         ***
# *** WARNING WARNING WARNING WARNING WARNING WARNING WARNING ***

# git-over-here: Switch multiple repositories from an old Git remote
#                to a new remote (and optionally to a new branch).
#
# Search for "help" below to learn how to use this.

# Copyright (c) 2022 Open Tech Strategies, LLC
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
# 
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# General Public License for more details.
# 
# If you did not receive a copy of the GNU General Public License
# along with this program, see <http://www.gnu.org/licenses/>.

help () {
  read -d '' HELP_OUTPUT << EOF
Usage:

   $ git-over-here -r OLD_REMOTE NEW_REMOTE [-b OLD_BRANCH NEW_BRANCH] DIR

From DIR downward switch every Git repository whose 'origin' remote is
OLD_REMOTE to NEW_REMOTE.  If OLD_REMOTE and NEW_REMOTE are the same,
then don't change any remotes, but use the specified remote to
determine which repositories the -b option (see below) affects.

If -b is added, then for all repositories that had an origin of
OLD_REMOTE, rename branch OLD_BRANCH to NEW_BRANCH and set origin's
upstream branch to NEW_REMOTE.  (A typical use is to change "master"
to "main" across a bunch of repositories.)

This script does not push to any remotes.  Our assumption is that
someone has already made the changes upstream and people just need to
update their local clones.

Matching of remote names is case-insensitive, but matching of
branch names is case-sensitive.

Both -r and DIR are required; -b is optional.  DIR must be the last
thing on the command line.

EOF
  echo "${HELP_OUTPUT}" >&2
}

ROOT_DIR=""
OLD_REMOTE=""
NEW_REMOTE=""
OLD_BRANCH=""
NEW_BRANCH=""

_MESSUP="no"  # set to "yes" if problem found in arg parsing

if [ "${1}" = "-r" ]
then
  OLD_REMOTE="${2}"
  NEW_REMOTE="${3}"
  if [ "${4}" = "-b" ]
  then
    OLD_BRANCH="${5}"
    NEW_BRANCH="${6}"
    ROOT_DIR="${7}"
  else
    ROOT_DIR="${4}"
  fi
else
  echo "ERROR: Missing -r option" >&2
  _MESSUP="yes"
fi

# If mis-invoked, carefully detect how and report it.
if [ "${OLD_REMOTE}" = "" ]; then
  echo "ERROR: Missing OLD_REMOTE" >&2
  _MESSUP="yes"
fi
if [ "${NEW_REMOTE}" = "" -o "${NEW_REMOTE}" = "-b" ]; then
  echo "ERROR: Missing NEW_REMOTE" >&2
  _MESSUP="yes"
fi
if [ "${ROOT_DIR}" = "" ]; then
  echo "ERROR: Missing DIR" >&2
  _MESSUP="yes"
fi
if [ "${OLD_BRANCH}" != "" -a "${NEW_BRANCH}" = "" ]; then
  _MESSUP="yes"
  echo "ERROR: Missing NEW_BRANCH" >&2
fi
if [ "${_MESSUP}" = "yes" ]; then
  echo "" >&2
  help
fi

for DOT_GIT_DIR in `find "${ROOT_DIR}" -type d -name "\.git" -print`; do
  SAVED_CWD="`pwd`"
  cd "${DOT_GIT_DIR}/../" || continue
  HERE_ORIGIN="`git remote get-url origin`"
  if [ "${HERE_ORIGIN,,}" = "${OLD_REMOTE,,}" ]; then
    echo "In '`pwd`':"
    # If the two remotes are equivalent (case-insensitively),
    # then don't touch the remote at all.
    if [ "${OLD_REMOTE,,}" != "${NEW_REMOTE,,}" ]; then
      # We don't pass "${OLD_REMOTE}" at the end below because Git's
      # confirmation check is (perhaps surprisingly) case-sensitive.
      git remote set-url origin "${NEW_REMOTE}"
      echo "  Switched origin remote to '${NEW_REMOTE}'."
    fi
    if [ "${OLD_BRANCH}" != "" ]; then
      # TODO: We might still need an adjustment like this?  But only
      #       if local HEAD had been pointing to tip of master, right?
      # 
      # git symbolic-ref refs/remotes/origin/HEAD refs/remotes/origin/"${NEW_BRANCH}"

      # If the new branch already exists, this will produce an error
      # (because we used -m instead of -M), which is what we want.
      git branch -m "${OLD_BRANCH}" "${NEW_BRANCH}"             \
        && git branch -u origin/"${NEW_BRANCH}" "${NEW_BRANCH}"
      echo "  Renamed '${OLD_BRANCH}' to '${NEW_BRANCH}'."
    fi
  fi
  cd "${SAVED_CWD}"
done
